<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chroma Key Test</title>
    <style>
        body {
            background: linear-gradient(45deg, #333 25%, transparent 25%, transparent 75%, #333 75%, #333),
                        linear-gradient(45deg, #333 25%, transparent 25%, transparent 75%, #333 75%, #333);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
            background-color: #222;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
            font-family: Arial;
        }
        .container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        video, canvas {
            width: 400px;
            height: 300px;
            border: 2px solid #555;
        }
        .controls {
            background: #333;
            padding: 20px;
            border-radius: 10px;
            max-width: 800px;
        }
        .control-group {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        label {
            width: 150px;
        }
        input[type="range"] {
            width: 200px;
        }
        input[type="color"] {
            width: 50px;
            height: 30px;
        }
        button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <h1>Chroma Key Test Page</h1>
    
    <div class="controls">
        <div class="control-group">
            <label>Video URL:</label>
            <input type="text" id="videoUrl" style="width: 400px;" placeholder="Enter video URL or path">
            <button onclick="loadVideo()">Load Video</button>
        </div>
        
        <div class="control-group">
            <label>Key Color:</label>
            <input type="color" id="keyColor" value="#00ff00">
            <button onclick="detectColor()">Auto Detect</button>
        </div>
        
        <div class="control-group">
            <label>Similarity:</label>
            <input type="range" id="similarity" min="0" max="100" value="40">
            <span id="similarityValue">40%</span>
        </div>
        
        <div class="control-group">
            <label>Smoothness:</label>
            <input type="range" id="smoothness" min="0" max="100" value="10">
            <span id="smoothnessValue">10%</span>
        </div>
        
        <div class="control-group">
            <label>Spill Suppression:</label>
            <input type="range" id="spill" min="0" max="100" value="10">
            <span id="spillValue">10%</span>
        </div>
        
        <div class="control-group">
            <button onclick="toggleChromaKey()">Toggle Chroma Key</button>
            <button onclick="downloadProcessed()">Download Processed</button>
        </div>
    </div>
    
    <div class="container">
        <div>
            <h3>Original Video</h3>
            <video id="originalVideo" controls loop></video>
        </div>
        <div>
            <h3>Processed Video</h3>
            <canvas id="processedCanvas"></canvas>
        </div>
    </div>

    <script>
        let chromaKeyEnabled = false;
        let animationId = null;
        
        const video = document.getElementById('originalVideo');
        const canvas = document.getElementById('processedCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        // Load sample green screen video
        video.src = '/uploads/sample-green-screen.mp4';
        
        // Update range values
        document.getElementById('similarity').addEventListener('input', (e) => {
            document.getElementById('similarityValue').textContent = e.target.value + '%';
        });
        
        document.getElementById('smoothness').addEventListener('input', (e) => {
            document.getElementById('smoothnessValue').textContent = e.target.value + '%';
        });
        
        document.getElementById('spill').addEventListener('input', (e) => {
            document.getElementById('spillValue').textContent = e.target.value + '%';
        });
        
        function loadVideo() {
            const url = document.getElementById('videoUrl').value;
            if (url) {
                video.src = url;
            }
        }
        
        function detectColor() {
            // Get color from video corners
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            tempCtx.drawImage(video, 0, 0);
            
            // Sample corner pixels
            const corners = [
                tempCtx.getImageData(0, 0, 1, 1).data,
                tempCtx.getImageData(tempCanvas.width - 1, 0, 1, 1).data,
                tempCtx.getImageData(0, tempCanvas.height - 1, 1, 1).data,
                tempCtx.getImageData(tempCanvas.width - 1, tempCanvas.height - 1, 1, 1).data
            ];
            
            // Average the colors
            let r = 0, g = 0, b = 0;
            corners.forEach(corner => {
                r += corner[0];
                g += corner[1];
                b += corner[2];
            });
            r = Math.round(r / 4);
            g = Math.round(g / 4);
            b = Math.round(b / 4);
            
            // Set the color
            const hex = '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
            document.getElementById('keyColor').value = hex;
            
            alert('Detected color: ' + hex);
        }
        
        function processFrame() {
            if (!chromaKeyEnabled) {
                cancelAnimationFrame(animationId);
                return;
            }
            
            // Set canvas size
            if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
            }
            
            // Draw current frame
            ctx.drawImage(video, 0, 0);
            
            // Get settings
            const keyColor = document.getElementById('keyColor').value;
            const similarity = parseFloat(document.getElementById('similarity').value) / 100;
            const smoothness = parseFloat(document.getElementById('smoothness').value) / 100;
            const spill = parseFloat(document.getElementById('spill').value) / 100;
            
            // Parse key color
            const hex = keyColor.replace('#', '');
            const keyR = parseInt(hex.substr(0, 2), 16);
            const keyG = parseInt(hex.substr(2, 2), 16);
            const keyB = parseInt(hex.substr(4, 2), 16);
            
            // Get image data
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Process pixels
            const maxDistance = 441.67; // sqrt(255^2 * 3)
            const threshold = (1 - similarity) * maxDistance;
            const smoothRange = smoothness * maxDistance;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Calculate distance
                const distance = Math.sqrt(
                    Math.pow(r - keyR, 2) +
                    Math.pow(g - keyG, 2) +
                    Math.pow(b - keyB, 2)
                );
                
                // Apply transparency
                if (distance < threshold) {
                    data[i + 3] = 0;
                } else if (distance < threshold + smoothRange) {
                    const alpha = (distance - threshold) / smoothRange;
                    data[i + 3] = Math.floor(alpha * 255);
                }
                
                // Spill suppression
                if (spill > 0 && data[i + 3] > 0) {
                    const spillFactor = Math.max(0, 1 - distance / threshold) * spill;
                    if (keyG > keyR && keyG > keyB) {
                        // Green screen
                        data[i + 1] = Math.max(data[i], data[i + 2], g * (1 - spillFactor));
                    }
                }
            }
            
            // Put processed image back
            ctx.putImageData(imageData, 0, 0);
            
            // Continue processing
            animationId = requestAnimationFrame(processFrame);
        }
        
        function toggleChromaKey() {
            chromaKeyEnabled = !chromaKeyEnabled;
            if (chromaKeyEnabled) {
                video.play();
                processFrame();
            } else {
                cancelAnimationFrame(animationId);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }
        
        function downloadProcessed() {
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'chromakey-frame.png';
                a.click();
                URL.revokeObjectURL(url);
            });
        }
        
        // Auto-start when video loads
        video.addEventListener('loadedmetadata', () => {
            console.log('Video loaded:', video.videoWidth + 'x' + video.videoHeight);
        });
    </script>
</body>
</html>